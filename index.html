<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>MathAR</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #000;
}

/* Video layers - Vision Pro style */
#video-sharp {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 0;
}

#video-blur {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
  filter: blur(80px) brightness(0.3) saturate(1.8);
  transform: scale(1.15);
  opacity: 0.85;
}

/* Glass morphism - Vision Pro aesthetic */
.glass {
  background: rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(40px) saturate(180%);
  -webkit-backdrop-filter: blur(40px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.18);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
              0 2px 8px rgba(0, 0, 0, 0.3),
              inset 0 1px 0 rgba(255, 255, 255, 0.15);
}

.glass-strong {
  background: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(40px) saturate(180%);
  -webkit-backdrop-filter: blur(40px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.22);
}

/* Splash screen */
#splash {
  position: fixed;
  inset: 0;
  z-index: 200;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  padding: 32px 20px;
  background: radial-gradient(ellipse at 50% 30%, rgba(79, 172, 254, 0.1) 0%, transparent 60%),
              rgba(0, 0, 0, 0.9);
  transition: opacity 0.6s, transform 0.6s;
}

#splash.hidden {
  opacity: 0;
  transform: scale(1.05);
  pointer-events: none;
}

.splash-card {
  max-width: 340px;
  width: 100%;
  padding: 28px 24px;
  border-radius: 28px;
}

.logo-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  margin-bottom: 24px;
}

.logo-icon {
  width: 64px;
  height: 64px;
  border-radius: 20px;
  background: linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(167, 139, 250, 0.3));
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  box-shadow: 0 8px 24px rgba(79, 172, 254, 0.2);
}

.logo-title {
  font-size: 32px;
  font-weight: 700;
  letter-spacing: -1px;
  background: linear-gradient(135deg, #fff 0%, rgba(255, 255, 255, 0.7) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.logo-subtitle {
  font-size: 11px;
  font-weight: 500;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.35);
}

.feature-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
}

.feature-row:last-child {
  border-bottom: none;
}

.feature-icon {
  width: 36px;
  height: 36px;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.07);
  border: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  flex-shrink: 0;
}

.feature-text {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.65);
  line-height: 1.4;
}

.feature-text strong {
  color: rgba(255, 255, 255, 0.95);
  font-weight: 600;
}

.btn-start {
  width: 100%;
  max-width: 340px;
  padding: 16px;
  border: none;
  border-radius: 16px;
  background: linear-gradient(135deg, rgba(79, 172, 254, 0.9), rgba(167, 139, 250, 0.9));
  color: #fff;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 8px 32px rgba(79, 172, 254, 0.35);
  transition: transform 0.15s;
}

.btn-start:active {
  transform: scale(0.97);
}

/* HUD */
#hud {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 50;
  display: none;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  padding-top: max(12px, env(safe-area-inset-top));
}

#hud.show {
  display: flex;
}

.hud-left {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 100px;
}

.hud-status-dot {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: #34d399;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.4;
  }
}

.hud-title {
  font-size: 15px;
  font-weight: 700;
  color: rgba(255, 255, 255, 0.95);
}

.hud-scan-btn {
  padding: 8px 18px;
  border-radius: 100px;
  border: none;
  background: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(40px);
  color: rgba(255, 255, 255, 0.95);
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.2s;
}

.hud-scan-btn:active {
  transform: scale(0.95);
}

/* Formula cards */
.formula-card {
  position: fixed;
  z-index: 40;
  max-width: 200px;
  min-width: 150px;
  padding: 14px 16px;
  border-radius: 20px;
  background: rgba(20, 20, 32, 0.75);
  backdrop-filter: blur(40px) saturate(180%);
  -webkit-backdrop-filter: blur(40px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.16);
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6),
              inset 0 1px 0 rgba(255, 255, 255, 0.1);
  cursor: pointer;
  animation: cardAppear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  touch-action: none;
}

@keyframes cardAppear {
  from {
    opacity: 0;
    transform: scale(0.6) translateY(10px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.formula-card.dragging {
  cursor: grabbing;
  box-shadow: 0 28px 70px rgba(0, 0, 0, 0.7);
}

.card-shine {
  position: absolute;
  top: 0;
  left: 20px;
  right: 20px;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
}

.card-close {
  position: absolute;
  top: 8px;
  right: 10px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.07);
  border: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: rgba(255, 255, 255, 0.5);
  cursor: pointer;
  z-index: 2;
}

.card-tag {
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  opacity: 0.6;
  margin-bottom: 4px;
}

.card-name {
  font-size: 12px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.95);
  margin-bottom: 2px;
  line-height: 1.3;
}

.card-equation {
  font-family: 'Menlo', 'Monaco', monospace;
  font-size: 17px;
  font-weight: 700;
  margin: 8px 0 6px;
  line-height: 1.1;
}

.card-description {
  font-size: 10.5px;
  color: rgba(255, 255, 255, 0.6);
  line-height: 1.45;
}

.card-hint {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(255, 255, 255, 0.07);
  font-size: 9px;
  color: rgba(255, 255, 255, 0.3);
  letter-spacing: 0.5px;
}

/* Detail panel */
#detail-panel {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding: 0 12px 24px;
  padding-bottom: max(24px, env(safe-area-inset-bottom));
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(8px);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s;
}

#detail-panel.open {
  opacity: 1;
  pointer-events: all;
}

.detail-sheet {
  width: 100%;
  max-width: 420px;
  background: rgba(18, 18, 28, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.16);
  border-radius: 28px;
  overflow: hidden;
  backdrop-filter: blur(40px) saturate(180%);
  box-shadow: 0 -8px 40px rgba(0, 0, 0, 0.5);
  transform: translateY(40px);
  transition: transform 0.4s cubic-bezier(0.34, 1.2, 0.64, 1);
}

#detail-panel.open .detail-sheet {
  transform: translateY(0);
}

.detail-handle {
  width: 36px;
  height: 4px;
  border-radius: 2px;
  background: rgba(255, 255, 255, 0.2);
  margin: 12px auto 0;
}

.detail-header {
  padding: 16px 20px 0;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
}

.detail-title-area {
  flex: 1;
}

.detail-tag {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  opacity: 0.5;
  margin-bottom: 3px;
}

.detail-title {
  font-size: 22px;
  font-weight: 700;
  color: rgba(255, 255, 255, 0.95);
  letter-spacing: -0.4px;
  line-height: 1.2;
}

.detail-close {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.12);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
  color: rgba(255, 255, 255, 0.6);
  cursor: pointer;
  flex-shrink: 0;
}

.detail-formula {
  margin: 14px 20px 0;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 16px;
  padding: 14px 20px;
  text-align: center;
  position: relative;
}

.detail-formula::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.25), transparent);
}

.detail-equation {
  font-family: 'Menlo', 'Monaco', monospace;
  font-size: 24px;
  font-weight: 700;
  letter-spacing: -0.5px;
}

.detail-animation {
  margin: 14px 20px 0;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.07);
  border-radius: 16px;
  overflow: hidden;
  height: 200px;
  position: relative;
}

#animation-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.detail-explanation {
  margin: 14px 20px;
  font-size: 13px;
  color: rgba(255, 255, 255, 0.6);
  line-height: 1.6;
}

.detail-variables {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin: 0 20px 20px;
}

.variable-chip {
  background: rgba(255, 255, 255, 0.07);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 5px 10px;
  font-family: 'Menlo', monospace;
  font-size: 11px;
  color: rgba(255, 255, 255, 0.6);
}

.variable-chip span {
  color: rgba(255, 255, 255, 0.95);
  font-weight: 600;
}

/* AI Scanning overlay */
#ai-scanning {
  position: fixed;
  inset: 0;
  z-index: 150;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  gap: 16px;
}

#ai-scanning.active {
  display: flex;
}

.ai-card {
  padding: 28px 36px;
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
}

.ai-spinner {
  width: 56px;
  height: 56px;
  border: 3px solid rgba(255, 255, 255, 0.1);
  border-top-color: #4facfe;
  border-right-color: #a78bfa;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.ai-title {
  font-size: 14px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.95);
}

.ai-subtitle {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
}

/* Toolbar */
#toolbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 50;
  display: none;
  padding: 10px 12px;
  padding-bottom: max(16px, env(safe-area-inset-bottom));
  background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 50%, transparent);
}

#toolbar.show {
  display: block;
}

.toolbar-label {
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 3px;
  color: rgba(255, 255, 255, 0.3);
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 8px;
}

.toolbar-scroll {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  scrollbar-width: none;
  padding: 2px;
}

.toolbar-scroll::-webkit-scrollbar {
  display: none;
}

.toolbar-item {
  flex-shrink: 0;
  min-width: 68px;
  padding: 10px 8px;
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  transition: all 0.18s;
}

.toolbar-item:active {
  transform: scale(0.94);
}

.toolbar-emoji {
  font-size: 22px;
}

.toolbar-name {
  font-size: 9px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.6);
  text-align: center;
  white-space: nowrap;
}

/* Canvas for connection lines */
#line-canvas {
  position: fixed;
  inset: 0;
  z-index: 25;
  pointer-events: none;
}

/* Scanline */
#scanline {
  position: fixed;
  left: 0;
  right: 0;
  height: 2px;
  z-index: 20;
  background: linear-gradient(90deg, transparent, rgba(79, 172, 254, 0.7), rgba(167, 139, 250, 0.7), transparent);
  animation: scanMove 6s linear infinite;
  pointer-events: none;
  display: none;
}

#scanline.active {
  display: block;
}

@keyframes scanMove {
  from {
    top: -2px;
  }
  to {
    top: 100vh;
  }
}

/* Error screen */
#error-screen {
  position: fixed;
  inset: 0;
  z-index: 300;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  padding: 32px;
  text-align: center;
}

#error-screen.show {
  display: flex;
}

.error-card {
  max-width: 320px;
  width: 100%;
  padding: 28px 24px;
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.error-icon {
  font-size: 40px;
}

.error-title {
  font-size: 18px;
  font-weight: 700;
  color: rgba(255, 255, 255, 0.95);
}

.error-message {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.6);
  line-height: 1.6;
}

.error-code {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 12px 16px;
  font-family: 'Menlo', monospace;
  font-size: 11px;
  color: #4facfe;
  line-height: 1.7;
  width: 100%;
  text-align: left;
}

.error-button {
  padding: 12px 24px;
  border-radius: 14px;
  border: none;
  background: rgba(255, 255, 255, 0.12);
  color: rgba(255, 255, 255, 0.95);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
}
</style>
</head>
<body>

<video id="video-sharp" autoplay playsinline muted></video>
<video id="video-blur" autoplay playsinline muted></video>
<canvas id="line-canvas"></canvas>

<!-- Splash Screen -->
<div id="splash">
  <div class="splash-card glass">
    <div class="logo-container">
      <div class="logo-icon">âˆ‘</div>
      <div class="logo-title">MathAR</div>
      <div class="logo-subtitle">Matematica nella realtÃ </div>
    </div>
    <div class="feature-row">
      <div class="feature-icon">ðŸ¤–</div>
      <div class="feature-text"><strong>L'AI analizza</strong> la scena e associa le formule fisicamente corrette</div>
    </div>
    <div class="feature-row">
      <div class="feature-icon">âœ¨</div>
      <div class="feature-text"><strong>Tocca una formula</strong> per vedere la dimostrazione animata</div>
    </div>
    <div class="feature-row">
      <div class="feature-icon">âœ‹</div>
      <div class="feature-text"><strong>Trascina e pizzica</strong> le formule nello spazio reale</div>
    </div>
  </div>
  <button class="btn-start" onclick="startAR()">ðŸ“· &nbsp;Avvia MathAR</button>
</div>

<!-- Error Screen -->
<div id="error-screen">
  <div class="error-card glass">
    <div class="error-icon">ðŸ”’</div>
    <div class="error-title">Fotocamera bloccata</div>
    <div class="error-message">Apri il link su HTTPS tramite GitHub Pages:</div>
    <div class="error-code">edilorenzo700-droid<br>.github.io/mathar</div>
    <button class="error-button" onclick="location.reload()">â†» &nbsp;Riprova</button>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-left glass">
    <div class="hud-status-dot"></div>
    <div class="hud-title">MathAR</div>
  </div>
  <button class="hud-scan-btn" onclick="scanScene()">
    <span id="scan-text">Scansiona</span>
  </button>
</div>

<!-- AI Scanning Overlay -->
<div id="ai-scanning">
  <div class="ai-card glass">
    <div class="ai-spinner"></div>
    <div class="ai-title">Analisi AI</div>
    <div class="ai-subtitle" id="ai-status">Riconosco gli oggetti...</div>
  </div>
</div>

<!-- Scanline -->
<div id="scanline"></div>

<!-- Detail Panel -->
<div id="detail-panel" onclick="closeDetailIfBackground(event)">
  <div class="detail-sheet">
    <div class="detail-handle"></div>
    <div class="detail-header">
      <div class="detail-title-area">
        <div class="detail-tag" id="detail-tag"></div>
        <div class="detail-title" id="detail-title"></div>
      </div>
      <div class="detail-close" onclick="closeDetail()">âœ•</div>
    </div>
    <div class="detail-formula">
      <div class="detail-equation" id="detail-equation"></div>
    </div>
    <div class="detail-animation">
      <canvas id="animation-canvas"></canvas>
    </div>
    <div class="detail-explanation" id="detail-explanation"></div>
    <div class="detail-variables" id="detail-variables"></div>
  </div>
</div>

<!-- Toolbar -->
<div id="toolbar">
  <div class="toolbar-label">+ aggiungi formula</div>
  <div class="toolbar-scroll" id="toolbar-scroll"></div>
</div>

<script>
// Formula database with correct physics
const FORMULAS = {
  lamp: {
    icon: 'ðŸ’¡',
    label: 'Sorgente luminosa',
    color: '#ffd080',
    keywords: ['lamp', 'light', 'bulb', 'chandelier', 'lantern', 'ceiling', 'spotlight'],
    formula: {
      name: 'Legge inverso del quadrato',
      equation: 'I = P / 4Ï€rÂ²',
      description: 'L\'intensitÃ  luminosa diminuisce col quadrato della distanza.',
      explanation: 'Raddoppiando la distanza dalla lampada, la luce si riduce di 4 volte. Una lampada da 60W a 1m ha Iâ‰ˆ4.8 W/mÂ². A 2m diventa â‰ˆ1.2 W/mÂ².',
      variables: [
        { symbol: 'I', meaning: 'IntensitÃ  (W/mÂ²)' },
        { symbol: 'P', meaning: 'Potenza (W)' },
        { symbol: 'r', meaning: 'Distanza (m)' }
      ],
      animation: 'inverseSquare'
    }
  },
  window: {
    icon: 'ðŸªŸ',
    label: 'Vetro Â· Rifrazione',
    color: '#8dd8ff',
    keywords: ['window', 'glass', 'pane', 'frame', 'door', 'curtain'],
    formula: {
      name: 'Legge di Snell',
      equation: 'nâ‚ sinÎ¸â‚ = nâ‚‚ sinÎ¸â‚‚',
      description: 'La luce cambia direzione passando tra due mezzi.',
      explanation: 'Il vetro di questa finestra (nâ‰ˆ1.5) rifrange un raggio a 45Â° portandolo a ~28Â°. Per questo gli oggetti sembrano spostati attraverso il vetro.',
      variables: [
        { symbol: 'nâ‚,nâ‚‚', meaning: 'Indici di rifrazione' },
        { symbol: 'Î¸â‚', meaning: 'Angolo incidente' },
        { symbol: 'Î¸â‚‚', meaning: 'Angolo rifratto' }
      ],
      animation: 'refraction'
    }
  },
  table: {
    icon: 'ðŸª‘',
    label: 'Superficie Â· Piano',
    color: '#80ffcc',
    keywords: ['table', 'desk', 'chair', 'floor', 'surface', 'furniture', 'shelf'],
    formula: {
      name: 'Attrito cinetico',
      equation: 'f = Î¼ Â· N',
      description: 'La forza che si oppone allo scivolamento.',
      explanation: 'Spingendo un libro (0.5kg) sul tavolo di legno (Î¼â‰ˆ0.3): f = 0.3 Ã— 4.9 = 1.47 N. L\'attrito ci permette di afferrare gli oggetti.',
      variables: [
        { symbol: 'f', meaning: 'Forza attrito (N)' },
        { symbol: 'Î¼', meaning: 'Coefficiente (~0.3 legno)' },
        { symbol: 'N', meaning: 'Forza normale (N)' }
      ],
      animation: 'friction'
    }
  },
  person: {
    icon: 'ðŸ§‘',
    label: 'Corpo in moto',
    color: '#ff9fd4',
    keywords: ['person', 'man', 'woman', 'human', 'face', 'body', 'people'],
    formula: {
      name: 'II Legge di Newton',
      equation: 'F = m Â· a',
      description: 'Forza = massa Ã— accelerazione.',
      explanation: 'Una persona di 70kg che accelera da 0 a 3m/s in 1s: F = 70 Ã— 3 = 210 N. I muscoli devono applicare questa forza.',
      variables: [
        { symbol: 'F', meaning: 'Forza (N)' },
        { symbol: 'm', meaning: 'Massa (kg)' },
        { symbol: 'a', meaning: 'Accelerazione (m/sÂ²)' }
      ],
      animation: 'newton'
    }
  },
  book: {
    icon: 'ðŸ“š',
    label: 'Algebra',
    color: '#c4a8ff',
    keywords: ['book', 'notebook', 'paper', 'laptop', 'computer', 'screen'],
    formula: {
      name: 'Formula quadratica',
      equation: 'x = (-b Â± âˆšÎ”) / 2a',
      description: 'Trova le radici di axÂ²+bx+c=0.',
      explanation: 'Se Î”=bÂ²-4ac>0: due soluzioni. Se Î”=0: soluzione doppia. Se Î”<0: soluzioni complesse.',
      variables: [
        { symbol: 'Î”', meaning: 'Discriminante = bÂ²-4ac' },
        { symbol: 'a,b,c', meaning: 'Coefficienti' }
      ],
      animation: 'quadratic'
    }
  },
  wall: {
    icon: 'ðŸ§±',
    label: 'Geometria',
    color: '#ffd080',
    keywords: ['wall', 'ceiling', 'building', 'room', 'corner'],
    formula: {
      name: 'Teorema di Pitagora',
      equation: 'aÂ² + bÂ² = cÂ²',
      description: 'Triangolo rettangolo: ipotenusaÂ² = somma catetiÂ².',
      explanation: 'Questo angolo del muro Ã¨ 90Â°. Il triangolo 3-4-5 Ã¨ pitagorico: 9+16=25. Gli egizi usavano corde con 12 nodi.',
      variables: [
        { symbol: 'a,b', meaning: 'Cateti' },
        { symbol: 'c', meaning: 'Ipotenusa' }
      ],
      animation: 'pythagoras'
    }
  }
};

// State
let cards = [];
let zIndex = 30;
let animationId = null;

// Canvas setup
const lineCanvas = document.getElementById('line-canvas');
const lineCtx = lineCanvas.getContext('2d');
const animCanvas = document.getElementById('animation-canvas');
const animCtx = animCanvas.getContext('2d');

function resizeCanvases() {
  lineCanvas.width = window.innerWidth;
  lineCanvas.height = window.innerHeight;
  animCanvas.width = animCanvas.offsetWidth;
  animCanvas.height = animCanvas.offsetHeight;
}

window.addEventListener('resize', resizeCanvases);
resizeCanvases();

// Start AR
async function startAR() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: 'environment' },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    });

    const videoSharp = document.getElementById('video-sharp');
    const videoBlur = document.getElementById('video-blur');
    
    videoSharp.srcObject = stream;
    videoBlur.srcObject = stream;
    
    await videoSharp.play();
    await videoBlur.play();

    document.getElementById('splash').classList.add('hidden');
    setTimeout(() => {
      document.getElementById('splash').style.display = 'none';
    }, 600);

    document.getElementById('hud').classList.add('show');
    document.getElementById('toolbar').classList.add('show');
    document.getElementById('scanline').classList.add('active');

    buildToolbar();
    drawLines();
    
    // Auto-scan after 1 second
    setTimeout(scanScene, 1000);

  } catch (error) {
    console.error('Camera error:', error);
    document.getElementById('error-screen').classList.add('show');
  }
}

// Scan scene with AI
async function scanScene() {
  const aiOverlay = document.getElementById('ai-scanning');
  const aiStatus = document.getElementById('ai-status');
  const scanText = document.getElementById('scan-text');
  
  aiOverlay.classList.add('active');
  scanText.textContent = 'Analisi...';
  aiStatus.textContent = 'Scatto il frame...';

  // Capture frame
  const video = document.getElementById('video-sharp');
  const canvas = document.createElement('canvas');
  canvas.width = Math.min(video.videoWidth || 640, 640);
  canvas.height = Math.min(video.videoHeight || 480, 480);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const imageData = canvas.toDataURL('image/jpeg', 0.75).split(',')[1];

  aiStatus.textContent = 'AI in analisi...';

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 150,
        messages: [{
          role: 'user',
          content: [
            {
              type: 'image',
              source: {
                type: 'base64',
                media_type: 'image/jpeg',
                data: imageData
              }
            },
            {
              type: 'text',
              text: 'List ONLY the main physical objects you see in this image. Reply with ONLY a comma-separated English list (max 5 items), no other text. Example: lamp, window, table, book, wall'
            }
          ]
        }]
      })
    });

    const data = await response.json();
    const rawText = data.content?.[0]?.text || '';
    const detected = rawText.toLowerCase().split(',').map(s => s.trim()).filter(Boolean);
    
    console.log('Detected objects:', detected);
    
    aiOverlay.classList.remove('active');
    renderFormulas(detected);

  } catch (error) {
    console.error('AI error:', error);
    aiOverlay.classList.remove('active');
    // Fallback
    renderFormulas(['table', 'lamp', 'wall']);
  }
}

// Render formula cards from detected objects
function renderFormulas(detectedObjects) {
  const matched = new Set();

  detectedObjects.forEach(word => {
    Object.entries(FORMULAS).forEach(([key, data]) => {
      if (data.keywords.some(kw => word.includes(kw) || kw.includes(word))) {
        matched.add(key);
      }
    });
  });

  if (matched.size === 0) {
    matched.add('table');
  }

  // Clear existing cards
  cards.forEach(card => {
    if (card.element) {
      card.element.remove();
    }
  });
  cards = [];

  const vw = window.innerWidth;
  const vh = window.innerHeight;

  const positions = [
    { x: vw * 0.05, y: vh * 0.12 },
    { x: vw * 0.48, y: vh * 0.09 },
    { x: vw * 0.04, y: vh * 0.46 },
    { x: vw * 0.48, y: vh * 0.48 }
  ];

  const origins = [
    { x: vw * 0.28, y: vh * 0.52 },
    { x: vw * 0.66, y: vh * 0.48 },
    { x: vw * 0.30, y: vh * 0.68 },
    { x: vw * 0.68, y: vh * 0.66 }
  ];

  Array.from(matched).slice(0, 4).forEach((key, index) => {
    const formulaData = FORMULAS[key];
    spawnCard(
      formulaData,
      key,
      positions[index] || { x: vw * 0.3, y: vh * 0.3 },
      origins[index] || { x: vw * 0.5, y: vh * 0.5 }
    );
  });

  document.getElementById('scan-text').textContent = `${matched.size} oggetti`;
}

// Spawn a formula card
function spawnCard(formulaData, key, position, origin) {
  const element = document.createElement('div');
  element.className = 'formula-card';
  element.style.left = position.x + 'px';
  element.style.top = position.y + 'px';
  element.style.zIndex = ++zIndex;
  element.style.borderColor = formulaData.color + '30';

  element.innerHTML = `
    <div class="card-shine"></div>
    <div class="card-close" onclick="removeCard(this.parentNode)">âœ•</div>
    <div class="card-tag" style="color: ${formulaData.color};">${formulaData.icon} ${formulaData.label}</div>
    <div class="card-name">${formulaData.formula.name}</div>
    <div class="card-equation" style="color: ${formulaData.color};">${formulaData.formula.equation}</div>
    <div class="card-description">${formulaData.formula.description}</div>
    <div class="card-hint">â–¶ tocca per la dimostrazione</div>
  `;

  document.body.appendChild(element);

  const card = {
    element: element,
    originX: origin.x,
    originY: origin.y,
    color: formulaData.color,
    formulaData: formulaData
  };

  cards.push(card);

  makeDraggable(element, card);
  makePinchable(element);

  // Tap to open detail
  let tapTimer;
  element.addEventListener('pointerdown', (e) => {
    if (e.target.classList.contains('card-close')) return;
    tapTimer = setTimeout(() => {
      openDetail(formulaData);
    }, 200);
  });
  element.addEventListener('pointermove', () => {
    clearTimeout(tapTimer);
  });

  return card;
}

// Remove card
function removeCard(element) {
  element.style.transition = 'opacity 0.3s, transform 0.3s';
  element.style.opacity = '0';
  element.style.transform = 'scale(0.5)';
  setTimeout(() => {
    element.remove();
    cards = cards.filter(c => c.element !== element);
  }, 300);
}

// Make card draggable
function makeDraggable(element, card) {
  let isDragging = false;
  let startX, startY, initialLeft, initialTop;

  function onPointerDown(e) {
    if (e.target.classList.contains('card-close')) return;

    isDragging = true;
    element.classList.add('dragging');
    element.style.zIndex = ++zIndex;

    const touch = e.touches ? e.touches[0] : e;
    startX = touch.clientX;
    startY = touch.clientY;
    initialLeft = parseFloat(element.style.left) || 0;
    initialTop = parseFloat(element.style.top) || 0;

    e.preventDefault();
  }

  function onPointerMove(e) {
    if (!isDragging) return;

    const touch = e.touches ? e.touches[0] : e;
    const dx = touch.clientX - startX;
    const dy = touch.clientY - startY;

    element.style.left = (initialLeft + dx) + 'px';
    element.style.top = (initialTop + dy) + 'px';

    if (card) {
      card.originX = parseFloat(element.style.left) + 100;
      card.originY = parseFloat(element.style.top) + 60;
    }

    e.preventDefault();
  }

  function onPointerUp() {
    isDragging = false;
    element.classList.remove('dragging');
  }

  element.addEventListener('touchstart', onPointerDown, { passive: false });
  element.addEventListener('touchmove', onPointerMove, { passive: false });
  element.addEventListener('touchend', onPointerUp);
  element.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
}

// Make card pinchable
function makePinchable(element) {
  let initialDistance = null;
  let initialScale = 1;

  element.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      initialDistance = getDistance(e.touches);
      initialScale = getCurrentScale(element);
    }
  }, { passive: true });

  element.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2 && initialDistance) {
      const currentDistance = getDistance(e.touches);
      const scale = Math.max(0.4, Math.min(2.5, initialScale * (currentDistance / initialDistance)));
      element.style.transform = `scale(${scale})`;
    }
  }, { passive: true });

  element.addEventListener('touchend', () => {
    initialDistance = null;
  });
}

function getDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getCurrentScale(element) {
  const transform = element.style.transform;
  if (!transform || transform === 'none') return 1;
  const match = transform.match(/scale\(([^)]+)\)/);
  return match ? parseFloat(match[1]) : 1;
}

// Open detail panel
function openDetail(formulaData) {
  document.getElementById('detail-tag').textContent = formulaData.icon + ' ' + formulaData.label;
  document.getElementById('detail-tag').style.color = formulaData.color;
  document.getElementById('detail-title').textContent = formulaData.formula.name;
  document.getElementById('detail-equation').textContent = formulaData.formula.equation;
  document.getElementById('detail-equation').style.color = formulaData.color;
  document.getElementById('detail-explanation').textContent = formulaData.formula.explanation;

  const varsContainer = document.getElementById('detail-variables');
  varsContainer.innerHTML = formulaData.formula.variables.map(v =>
    `<div class="variable-chip"><span>${v.symbol}</span> = ${v.meaning}</div>`
  ).join('');

  document.getElementById('detail-panel').classList.add('open');
  
  resizeCanvases();
  setTimeout(() => {
    runAnimation(formulaData.formula.animation, formulaData.color);
  }, 400);
}

// Close detail panel
function closeDetail() {
  document.getElementById('detail-panel').classList.remove('open');
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
  animCtx.clearRect(0, 0, animCanvas.width, animCanvas.height);
}

function closeDetailIfBackground(event) {
  if (event.target === document.getElementById('detail-panel')) {
    closeDetail();
  }
}

// Run animations
function runAnimation(type, color) {
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }

  animCanvas.width = animCanvas.offsetWidth;
  animCanvas.height = animCanvas.offsetHeight;
  
  const W = animCanvas.width;
  const H = animCanvas.height;
  let t = 0;

  const hexToRgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
  };

  const [R, G, B] = hexToRgb(color || '#8dd8ff');
  const rgba = `rgba(${R},${G},${B}`;

  const animations = {
    pythagoras: () => {
      animCtx.clearRect(0, 0, W, H);
      const progress = Math.min(t / 140, 1);
      const ox = W * 0.15;
      const oy = H * 0.76;
      const a = H * 0.48 * progress;
      const b = W * 0.48 * progress;

      animCtx.strokeStyle = `${rgba},${0.6 + 0.4 * progress})`;
      animCtx.lineWidth = 2.5;
      animCtx.lineCap = 'round';
      animCtx.lineJoin = 'round';

      // Triangle
      animCtx.beginPath();
      animCtx.moveTo(ox, oy);
      animCtx.lineTo(ox, oy - a);
      animCtx.lineTo(ox + b, oy);
      animCtx.closePath();
      animCtx.stroke();

      // Right angle marker
      const rs = 12;
      animCtx.beginPath();
      animCtx.moveTo(ox + rs, oy);
      animCtx.lineTo(ox + rs, oy - rs);
      animCtx.lineTo(ox, oy - rs);
      animCtx.stroke();

      // Labels
      if (progress > 0.4) {
        animCtx.fillStyle = `${rgba},0.9)`;
        animCtx.font = 'bold 13px Menlo';
        animCtx.textAlign = 'center';
        animCtx.fillText('a', ox - 16, oy - a / 2);
        animCtx.fillText('b', ox + b / 2, oy + 16);
      }

      if (progress > 0.85) {
        animCtx.fillStyle = `${rgba},1)`;
        animCtx.font = 'bold 15px Menlo';
        animCtx.fillText('c', ox + b / 2 + 16, oy - a / 2 - 10);
      }

      // Squares
      if (progress > 0.6) {
        const alpha = Math.min((progress - 0.6) / 0.2, 1);
        animCtx.globalAlpha = alpha * 0.2;
        animCtx.fillStyle = `${rgba},1)`;
        animCtx.fillRect(ox - a, oy - a, a, a);
        animCtx.fillRect(ox, oy, b, b);
        animCtx.globalAlpha = 1;
        animCtx.strokeStyle = `${rgba},${alpha * 0.35})`;
        animCtx.lineWidth = 1;
        animCtx.strokeRect(ox - a, oy - a, a, a);
        animCtx.strokeRect(ox, oy, b, b);
      }

      animCtx.textAlign = 'left';
      t++;
      animationId = requestAnimationFrame(animations.pythagoras);
    },

    inverseSquare: () => {
      animCtx.clearRect(0, 0, W, H);
      const cx = W * 0.1;
      const cy = H / 2;
      
      // Expanding rings
      for (let i = 0; i < 5; i++) {
        const phase = (t / 60 + i / 5) % 1;
        const r = phase * W * 0.85;
        const alpha = (1 - phase) * 0.4;
        animCtx.strokeStyle = `${rgba},${alpha})`;
        animCtx.lineWidth = 1.5;
        animCtx.beginPath();
        animCtx.arc(cx, cy, r, -0.8, 0.8);
        animCtx.stroke();
      }

      // Source
      animCtx.fillStyle = `${rgba},0.95)`;
      animCtx.beginPath();
      animCtx.arc(cx, cy, 8, 0, Math.PI * 2);
      animCtx.fill();

      // Intensity curve
      animCtx.strokeStyle = 'rgba(255,255,255,0.3)';
      animCtx.lineWidth = 1.5;
      animCtx.beginPath();
      for (let x = 20; x <= W * 0.9; x += 2) {
        const d = x - cx;
        if (d <= 0) continue;
        const intensity = H * 0.4 / (d / 30);
        const y = cy - Math.min(intensity, H * 0.45);
        if (x <= 22) {
          animCtx.moveTo(x, y);
        } else {
          animCtx.lineTo(x, y);
        }
      }
      animCtx.stroke();

      animCtx.fillStyle = 'rgba(255,255,255,0.35)';
      animCtx.font = '11px Inter';
      animCtx.fillText('I âˆ 1/rÂ²', W * 0.55, H * 0.15);

      t++;
      animationId = requestAnimationFrame(animations.inverseSquare);
    },

    refraction: () => {
      animCtx.clearRect(0, 0, W, H);
      const mx = W / 2;
      const my = H / 2;

      // Interface
      animCtx.strokeStyle = 'rgba(255,255,255,0.18)';
      animCtx.lineWidth = 1;
      animCtx.setLineDash([4, 5]);
      animCtx.beginPath();
      animCtx.moveTo(0, my);
      animCtx.lineTo(W, my);
      animCtx.stroke();

      // Normal
      animCtx.beginPath();
      animCtx.moveTo(mx, 0);
      animCtx.lineTo(mx, H);
      animCtx.stroke();
      animCtx.setLineDash([]);

      // Labels
      animCtx.fillStyle = 'rgba(255,255,255,0.3)';
      animCtx.font = '11px Inter';
      animCtx.fillText('Aria n=1.0', W * 0.05, my - 12);
      animCtx.fillText('Vetro n=1.5', W * 0.05, my + 22);

      // Incident ray
      const angle1 = 35 * Math.PI / 180;
      const rayLength = H * 0.4;
      const ex = mx - Math.sin(angle1) * rayLength;
      const ey = my - Math.cos(angle1) * rayLength;

      animCtx.strokeStyle = `${rgba},${0.4 + 0.4 * Math.abs(Math.sin(t / 40))})`;
      animCtx.lineWidth = 2.5;
      animCtx.beginPath();
      animCtx.moveTo(ex, ey);
      animCtx.lineTo(mx, my);
      animCtx.stroke();

      // Refracted ray
      const angle2 = Math.asin(Math.sin(angle1) / 1.5);
      const rx = mx + Math.sin(angle2) * rayLength * 0.8;
      const ry = my + Math.cos(angle2) * rayLength * 0.8;

      animCtx.strokeStyle = `${rgba},0.85)`;
      animCtx.lineWidth = 2.5;
      animCtx.beginPath();
      animCtx.moveTo(mx, my);
      animCtx.lineTo(rx, ry);
      animCtx.stroke();

      animCtx.fillStyle = `${rgba},0.75)`;
      animCtx.font = 'bold 12px Menlo';
      animCtx.textAlign = 'center';
      animCtx.fillText('Î¸â‚â‰ˆ35Â°', mx + 22, my - 28);
      animCtx.fillText('Î¸â‚‚â‰ˆ22Â°', mx + 22, my + 38);
      animCtx.textAlign = 'left';

      t++;
      animationId = requestAnimationFrame(animations.refraction);
    },

    newton: () => {
      animCtx.clearRect(0, 0, W, H);
      const progress = Math.min(t / 90, 1);
      const startX = W * 0.08;
      const endX = W * 0.82;
      const y = H / 2;
      const cx = startX + progress * (endX - startX);

      // Ground
      animCtx.strokeStyle = 'rgba(255,255,255,0.12)';
      animCtx.lineWidth = 1;
      animCtx.beginPath();
      animCtx.moveTo(0, y + 24);
      animCtx.lineTo(W, y + 24);
      animCtx.stroke();

      // Mass
      animCtx.fillStyle = `${rgba},0.15)`;
      animCtx.strokeStyle = `${rgba},0.7)`;
      animCtx.lineWidth = 2;
      animCtx.fillRect(cx - 22, y - 22, 44, 44);
      animCtx.strokeRect(cx - 22, y - 22, 44, 44);

      animCtx.fillStyle = `${rgba},1)`;
      animCtx.font = 'bold 13px Menlo';
      animCtx.textAlign = 'center';
      animCtx.fillText('m', cx, y + 5);

      // Force arrow
      const arrowLength = 55 + progress * 30;
      animCtx.strokeStyle = '#ffd080';
      animCtx.fillStyle = '#ffd080';
      animCtx.lineWidth = 2.5;
      animCtx.beginPath();
      animCtx.moveTo(cx + 22, y);
      animCtx.lineTo(cx + 22 + arrowLength, y);
      animCtx.stroke();
      animCtx.beginPath();
      animCtx.moveTo(cx + 22 + arrowLength, y - 7);
      animCtx.lineTo(cx + 22 + arrowLength + 11, y);
      animCtx.lineTo(cx + 22 + arrowLength, y + 7);
      animCtx.fill();

      animCtx.font = 'bold 11px Menlo';
      animCtx.fillText('F', cx + 22 + arrowLength / 2, y - 10);

      animCtx.fillStyle = 'rgba(255,255,255,0.5)';
      animCtx.font = '12px Inter';
      animCtx.fillText(`a = ${(progress * 5).toFixed(1)} m/sÂ²`, W * 0.42, H * 0.18);
      animCtx.textAlign = 'left';

      if (progress >= 1) {
        t = 0;
      } else {
        t++;
      }
      animationId = requestAnimationFrame(animations.newton);
    },

    quadratic: () => {
      animCtx.clearRect(0, 0, W, H);
      const ox = W / 2;
      const oy = H * 0.78;
      const scale = W * 0.038;

      // Axes
      animCtx.strokeStyle = 'rgba(255,255,255,0.15)';
      animCtx.lineWidth = 1;
      animCtx.beginPath();
      animCtx.moveTo(0, oy);
      animCtx.lineTo(W, oy);
      animCtx.stroke();
      animCtx.beginPath();
      animCtx.moveTo(ox, 0);
      animCtx.lineTo(ox, H);
      animCtx.stroke();

      // Animated parabola
      const b = -2 * Math.sin(t / 55);
      const c = -2.5;

      animCtx.strokeStyle = `${rgba},0.85)`;
      animCtx.lineWidth = 2.5;
      animCtx.beginPath();
      for (let px = 0; px <= W; px += 2) {
        const x = (px - ox) / scale;
        const py = oy - (x * x + b * x + c) * scale * 5;
        if (px === 0) {
          animCtx.moveTo(px, py);
        } else {
          animCtx.lineTo(px, py);
        }
      }
      animCtx.stroke();

      // Roots
      const discriminant = b * b - 4 * c;
      if (discriminant >= 0) {
        const x1 = (-b + Math.sqrt(discriminant)) / 2;
        const x2 = (-b - Math.sqrt(discriminant)) / 2;
        [x1, x2].forEach(x => {
          const px = ox + x * scale;
          animCtx.fillStyle = `${rgba},1)`;
          animCtx.beginPath();
          animCtx.arc(px, oy, 5, 0, Math.PI * 2);
          animCtx.fill();
        });
      }

      animCtx.fillStyle = `${rgba},0.65)`;
      animCtx.font = '11px Inter';
      animCtx.textAlign = 'center';
      animCtx.fillText('Î”=bÂ²-4ac', ox, H * 0.1);
      animCtx.textAlign = 'left';

      t++;
      animationId = requestAnimationFrame(animations.quadratic);
    },

    friction: () => {
      animCtx.clearRect(0, 0, W, H);
      const progress = (Math.sin(t / 80) + 1) / 2;
      const bx = W * 0.1 + progress * (W * 0.52);
      const by = H * 0.42;

      // Surface
      animCtx.fillStyle = 'rgba(255,255,255,0.05)';
      animCtx.fillRect(0, by + 28, W, H);
      animCtx.strokeStyle = 'rgba(255,255,255,0.18)';
      animCtx.lineWidth = 1;
      animCtx.beginPath();
      animCtx.moveTo(0, by + 28);
      animCtx.lineTo(W, by + 28);
      animCtx.stroke();

      // Box
      animCtx.fillStyle = `${rgba},0.15)`;
      animCtx.strokeStyle = `${rgba},0.7)`;
      animCtx.lineWidth = 2;
      animCtx.fillRect(bx - 24, by - 24, 48, 52);
      animCtx.strokeRect(bx - 24, by - 24, 48, 52);

      // Normal force
      animCtx.strokeStyle = '#80ffcc';
      animCtx.fillStyle = '#80ffcc';
      animCtx.lineWidth = 2;
      animCtx.beginPath();
      animCtx.moveTo(bx, by - 24);
      animCtx.lineTo(bx, by - 60);
      animCtx.stroke();
      animCtx.beginPath();
      animCtx.moveTo(bx - 6, by - 54);
      animCtx.lineTo(bx, by - 66);
      animCtx.lineTo(bx + 6, by - 54);
      animCtx.fill();

      animCtx.font = 'bold 11px Menlo';
      animCtx.textAlign = 'center';
      animCtx.fillText('N', bx + 9, by - 50);

      // Friction
      const direction = Math.cos(t / 80) > 0 ? -1 : 1;
      animCtx.strokeStyle = '#ff9fd4';
      animCtx.fillStyle = '#ff9fd4';
      animCtx.lineWidth = 2;
      animCtx.beginPath();
      animCtx.moveTo(bx - 24, by + 4);
      animCtx.lineTo(bx - 24 + direction * (-52), by + 4);
      animCtx.stroke();

      animCtx.fillText('f', bx - 24 + direction * (-26), by - 5);

      animCtx.fillStyle = 'rgba(255,255,255,0.4)';
      animCtx.font = '11px Inter';
      animCtx.fillText('f = Î¼Â·N', W * 0.58, H * 0.15);
      animCtx.textAlign = 'left';

      t++;
      animationId = requestAnimationFrame(animations.friction);
    }
  };

  const animFunction = animations[type] || animations.pythagoras;
  animFunction();
}

// Draw connection lines
function drawLines() {
  lineCtx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
  const time = performance.now();

  cards.forEach(card => {
    if (!card.element || !card.element.isConnected) return;

    const rect = card.element.getBoundingClientRect();
    const cardX = rect.left + rect.width / 2;
    const cardY = rect.top + rect.height / 2;

    const hexToRgb = (hex) => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return [r, g, b];
    };

    const [r, g, b] = hexToRgb(card.color || '#8dd8ff');

    lineCtx.save();
    
    // Animated dashed line
    lineCtx.setLineDash([3, 7]);
    lineCtx.lineDashOffset = -(time / 55);
    lineCtx.strokeStyle = `rgba(${r},${g},${b},0.35)`;
    lineCtx.lineWidth = 1;
    lineCtx.beginPath();
    lineCtx.moveTo(card.originX, card.originY);
    lineCtx.lineTo(cardX, cardY);
    lineCtx.stroke();
    lineCtx.setLineDash([]);

    // Origin dot
    lineCtx.fillStyle = `rgba(${r},${g},${b},0.9)`;
    lineCtx.beginPath();
    lineCtx.arc(card.originX, card.originY, 4, 0, Math.PI * 2);
    lineCtx.fill();

    // Ripple
    const ripplePhase = (time % 2400) / 2400;
    lineCtx.strokeStyle = `rgba(${r},${g},${b},${(1 - ripplePhase) * 0.45})`;
    lineCtx.lineWidth = 1.2;
    lineCtx.beginPath();
    lineCtx.arc(card.originX, card.originY, ripplePhase * 30, 0, Math.PI * 2);
    lineCtx.stroke();

    lineCtx.restore();
  });

  requestAnimationFrame(drawLines);
}

// Build toolbar
function buildToolbar() {
  const scroll = document.getElementById('toolbar-scroll');
  
  Object.entries(FORMULAS).forEach(([key, data]) => {
    const item = document.createElement('div');
    item.className = 'toolbar-item';
    item.innerHTML = `
      <div class="toolbar-emoji">${data.icon}</div>
      <div class="toolbar-name" style="color: ${data.color};">${data.label.split('Â·')[0].trim()}</div>
    `;
    
    item.addEventListener('pointerdown', () => {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      spawnCard(
        data,
        key,
        { x: vw * 0.1 + Math.random() * vw * 0.6, y: vh * 0.1 + Math.random() * vh * 0.4 },
        { x: vw * 0.5, y: vh * 0.55 }
      );
    });
    
    scroll.appendChild(item);
  });
}

// Prevent default touch behavior
document.addEventListener('touchmove', (e) => {
  e.preventDefault();
}, { passive: false });
</script>

</body>
</html>
